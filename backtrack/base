// 记录所有全排列
List<List<Integer>> res = new LinkedList<>();
LinkedList<Integer> track = new LinkedList<>();

/* 主函数，输入一组不重复的数字，返回它们的全排列 */
List<List<Integer>> permute(int[] nums) {
    backtrack(nums);
    return res;
}

// 回溯算法框架
void backtrack(int[] nums, track) {
    if (track.size() == nums.length) {
        // 穷举完一个全排列
        res.add(new LinkedList(track));
        return;
    }

    for (int i = 0; i < nums.length; i++) {
        if (track.contains(nums[i]))
            continue;
        // 前序遍历位置做选择
        track.add(nums[i]);
        backtrack(nums, track);
        // 后序遍历位置取消选择
        track.removeLast();
    }
}

List<List<Integer>> permute(int[] nums){
    backtrack(nums);
    return res;
}


void backtrack(int[] nums){
    if(track.size() == nums.length){
        res.add(new LinkedList(track));
        return;
    }

    for(int i = 0; i < nums.length; i++){
        if(track.contains(nums[i]))
            continue;
        track.add(nums[i]);
        backtrack(nums, track);
        track.removeLast();
    }
}

List<List<Integer>> premute(int[] nums){
    backtrack(nums);
    return res;
}


void backtrack(int[] nums, List<Integer> track){
    if(track.size() == nums.length){
        res.add(new LinkedList(track));
        return;
    }
    for(int i: nums){
        if(track.contains(nums[i])){
            continue
        }
        track.add(nums[i])
        backtrack(nums, track)
        track.removeLast()
    }
}


void backtrack(int[] nums, List<Integer> track){
    if(track.size()== nums.length){
        res.add(new LinkedList(track));
        return;
    }
    for(int i : nums){
        if(track.contains(nums[i])){
            continue;
        }
        track.add(nums[i])
        backtrack(nums, track);
        track.removeLast()
    }
}

List<List<Integer>> res = new LinkedList<>();
LinkedList<Integer> track = new LinkedList<>();

List<List<Integer>> res = new LinkedList<>();
LinkedList<Integer> track = new LinkedList<>();

List<List<Integer>> permute(int[] nums){
    backtrack(nums);
    return res;
}


void backtrack(int[] nums, List<Integer> track){
    if(track.size() == nums.length){
        res.add(new LinkedList(track));
        return;
    }
    for(int i : nums){
        if(track.contains(nums[i]))
            continue;
        track.add(nums[i])
        backtrack(nnu)
        track.removeLast();
    }
}